module main {

    /* Type encoding */
    type addr_t = bv64;
    type ca_t = bv64;
    type data_t = bv64;
    type pid_t = bv1;
    type mem_t = [addr_t]data_t;

    /* State variables */
    var memory      :   mem_t;
    var pointer_key :   bv24;
    var data_key    :   bv24;

    // If doesn't end up terminating,
    // addr_alloc : [alloc_ind_t]bv64;
    // alloc_ind_t : bv3
    var addr_alloc  :   [addr_t]bv64; // map of allocated addresses with their size
    var addr_is_alloc  :   [addr_t]boolean; // lets us know if an addr is allocated.

    /* Procedures that describe unit behavior */

    define log2ceil(arg : bv64) : bv6 = if (arg < 2bv64) then 0bv6 else 1bv6;
    define fold_op(arg : bv40) : bv24 = arg[23 : 0] ^ (0bv24 | arg[39 : 24]);

    define k_cipher(
                plaintext : bv24,
                key : bv24,
                tweak : bv24) : bv24 = plaintext ^ key ^ tweak;

    define get_fixed_addr (power : bv6, addr: addr_t) : bv34 =
        (bv_l_right_shift(addr, 0bv58 ++ power) & (bv_left_shift(33bv64 - (0bv58 ++ power) + 2bv64, 1bv64) - 1bv64))[33:0];

    define get_offset (power : bv6, addr: addr_t) : bv34 =
        (addr & (bv_left_shift((0bv58 ++ power) + 1bv64, 1bv64) - 1bv64))[33 : 0];

    function generate_addr (size : bv64) : addr_t;

    // Allocate memory, takes in a size.
    procedure malloc(size : bv64)
        returns (ca : ca_t)
        modifies memory, addr_alloc, addr_is_alloc;
        requires (size > 0bv64);
    {
        // The address we generate given the size.
        var addr : addr_t;

        // Parts of the address
        var padded_fixed_addr : bv34;
        var padded_offset : bv34;
        var upper_addr : bv24;

        // Arguments for K-Cipher
        var key : bv24; // pointer key
        var power : bv6;
        var tweak : bv24;

        var encrypted_slice : bv24;

        // generate raw physical address from the allocator
        addr = generate_addr(size);
        assume (addr_is_alloc[addr] == false);
        addr_alloc[addr] = size;
        addr_is_alloc[addr] = true;

        // LAM48 format. (page 11 of C^3 spec)
        upper_addr = addr[47 : 34];

        // setup the tweak
        power = log2ceil(size);

        padded_offset = get_offset(power, addr);
        padded_fixed_addr = get_fixed_addr(power, addr);

        // Sanity check that we extracted the correct things
        assert ((padded_offset | padded_fixed_addr) == addr[33:0]);

        tweak = fold_op(power ++ padded_fixed_addr);

        // k-cipher, return cryptographic address 
        encrypted_slice = k_cipher(upper_addr, key, tweak);
        ca = power ++ encrypted_slice ++ addr[33 : 0];
    }

    init {
        // no allocations, all set to 0.
        assume (forall (i : addr_t) :: addr_alloc[i] == 0bv64);
        //assume (forall (i : addr_t) :: addr_is_alloc[i] == false);
    }

    next {
        /*
        var s   : bv64;
        var allocation  : ca_t;
        assume (s > 0bv64);

        'allocation = malloc(s);
        */
    }

    control {
    }

}
