module main {

    /* Type encoding */
    type addr_t = bv64;
    type ca_t = bv64;
    type data_t = bv8;
    type pid_t = bv1;
    type mem_t = [addr_t]data_t; // byte addressable memory

    /* State variables */
    var memory      :   mem_t;
    var pointer_key :   bv24;
    var data_key    :   bv24;
    // TODO pointer_key and data_key will need to be per process.
    // spec 0.5 says these keys should be 72 bits

    /* Specifies the size of a given allocation */
    //var addr_alloc  :   [addr_t]bv64;

    /* True if there's an active allocation of addr_t (for allocator use) */
    var addr_is_alloc  :   [addr_t]boolean;

    /* spec p14 defines maximum allocation size */
    define MAX_ALLOC_SIZE() : bv64 = 4000000000bv64;
    define S_PRIME_IDX() : integer = 47;
    define S_IDX() : integer = 63;

    /* Calculates the tweak to be used with K-Cipher */
    define calculate_tweak(arg : bv38) : bv24 =
        arg[23 : 0] ^ (0bv10 ++ arg[37 : 24]);

    define k_cipher(
                plaintext : bv24,
                key : bv24,
                tweak : bv24) : bv24 = plaintext ^ key ^ tweak;
    // TODO need to define axioms for cryptographic unit.

    /* Extracts bits [31 : power] from addr */
    define get_fixed_addr (power : bv6, addr: addr_t) : bv32 =
        bv_left_shift(0bv58 ++ power,
            bv_l_right_shift(0bv58 ++ power, addr & 4294967295bv64))[31 : 0];

    /* Extracts bits [power - 1 : 0] from addr */
    define get_offset (power : bv6, addr: addr_t) : bv32 =
        (bv_l_right_shift((64bv64 - (0bv58 ++ power)),
            bv_left_shift((64bv64 - (0bv58 ++ power)), addr)))[31:0];

    /* Generates a raw address */
    function generate_addr (size : bv64) : addr_t;

    /* Get the power bits from the size */
    function generate_power (size : bv64) : bv6;

    define begin (): bv64 = 0bv64;

    /* Generates a CA given a size */
    procedure malloc(size : bv64)
        returns (ca : ca_t)
        modifies addr_is_alloc, prev_raw, memory;
        requires ((size >_u 0bv64) && (size <=_u MAX_ALLOC_SIZE()));
    {
        // The address we generate given the size.
        var addr : addr_t;
        var _i  : bv64;

        // Parts of the address
        var padded_fixed_addr : bv32;
        var padded_offset : bv32;
        var upper_addr : bv15;
        var s : bv1;
        var s_prime: bv1;

        // Arguments for K-Cipher
        var power : bv6;
        var tweak : bv24;

        var encrypted_slice : bv24;

        // Generate address and make sure it has enough space.
        addr = generate_addr(size);

        // TODO for testing
        assume (forall (i : bv64) :: ((i >=_u 0bv64) &&
            (i <_u size)) ==> (addr_is_alloc[addr + i] == false));
        _i = 0bv64;

        while (_i <_u size)
            invariant ((_i >=_u 0bv64) && (_i <=_u size));
            invariant (forall (i : bv64) :: (i >= 0bv64 && i < _i) ==> ((memory[addr + i] == 0bv8)));
        {
            addr_is_alloc[addr + _i] = true;
            memory[addr + _i] = 0bv8;
            _i = _i + 1bv64;
        }

        // generate power, assign power of two slot
        power = generate_power(size);
        assume (bv_l_right_shift(0bv58 ++ power,
            addr ^ (addr + (size - 1bv64))) == 0bv64);
        power = power + 1bv6;
        prev_raw = addr;

        // LAM48 spec
        upper_addr = addr[46 : 32];
        s = addr[S_IDX() : S_IDX()];
        s_prime = addr[S_PRIME_IDX() : S_PRIME_IDX()];

        // setup the tweak
        padded_offset = get_offset(power, addr);
        padded_fixed_addr = get_fixed_addr(power, addr);
        assert ((padded_offset | padded_fixed_addr) == addr[31:0]);

        tweak = calculate_tweak(power ++ padded_fixed_addr);

        // Throw everything into the K-Cipher
        encrypted_slice = k_cipher(0bv9 ++ upper_addr, pointer_key, tweak);

        // Return CA as defined in spec, rev. 0.5
        ca = s ++ power ++ encrypted_slice[23 : 15]
                ++ s_prime ++ encrypted_slice[14 : 0] ++ addr[31 : 0];
    }

    var page_fault : boolean;
    var herro : bv64;

    /* Read a byte */
    procedure read_byte(ca : ca_t)
        returns (byte : data_t)
        modifies page_fault, herro;
        requires (ca >=_u 0bv64);
    {
        // Bounds checking variables
        var slot_start : bv64;
        var slot_end : bv64;

        var decoded_addr : addr_t;
        var power : bv6;
        power = ca[62 : 57];
        call (decoded_addr) = decode_addr(ca);
        assert (prev_raw == decoded_addr);
        herro = decoded_addr;

        // Get slot start
        slot_start = bv_left_shift(0bv58 ++ (power - 1bv6),
            bv_l_right_shift(0bv58 ++ (power - 1bv6), decoded_addr));

        slot_end = bv_left_shift(0bv58 ++ (power - 1bv6),
            bv_l_right_shift(0bv58 ++ (power - 1bv6), decoded_addr) + 1bv64);

        slot_end = slot_end - 1bv64;

        page_fault = (decoded_addr <_u slot_start)
            || (decoded_addr >_u slot_end);

        if (page_fault) {
            byte = 13bv8;
        } else {
            byte = memory[decoded_addr];
        }
    }

    /* Decodes the CA back to the raw address */
    procedure decode_addr(ca : ca_t)
        returns (decoded_addr : addr_t)
        requires (ca >=_u 0bv64);
    {
        var ciphertext : bv24;
        var power : bv6;
        var padded_fixed_addr : bv32;
        var tweak : bv24;

        var plain_addr : bv15;

        power = ca[62 : 57];
        ciphertext = ca[56 : 48] ++ ca[46 : 32];
        padded_fixed_addr = get_fixed_addr(power, ca);
        tweak = calculate_tweak(power ++ padded_fixed_addr);
        plain_addr = k_cipher(ciphertext, pointer_key, tweak)[14 : 0];

        decoded_addr = ca[S_IDX() : S_IDX()]
            ++ bv_sign_extend(15, ca[S_PRIME_IDX() : S_PRIME_IDX()])
            ++ plain_addr ++ ca[31 : 0];
    }

    init {
        alloc = 0bv64;
        prev_raw = 0bv64;

        herro = 0bv64;
        page_fault = false;
        alloc_raw = 0bv64;
        byte = 0bv8;
        size = 1bv64;
        assume (forall (i : addr_t) :: addr_is_alloc[i] == false);
    }

    /**
    * Testbench
    */
    var alloc : ca_t;
    var prev_raw : addr_t;
    var alloc_raw : addr_t;
    var byte : data_t;
    var size : bv64;

    invariant valid_access_1 : page_fault == false;
    invariant valid_access_2 : byte == 0bv8;

    axiom size_lim : ((size >_u 0bv64) && (size <=_u MAX_ALLOC_SIZE())); 

    next {
        havoc size;

        call (alloc') = malloc(size);
        call (alloc_raw') = decode_addr(alloc');
        
        assert (prev_raw' == alloc_raw');

        pointer_key' = pointer_key;
    }

    control {
        f = bmc(2);
        check;
        f.print_cex();
        print_results;
    }

}
